<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>The Datagram Transport Layer Security (DTLS) Protocol Version 1.3</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Conventions and Terminology"/>
<link href="#rfc.section.3" rel="Chapter" title="3 DTLS Design Rational and Overview"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Packet Loss"/>
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Reordering"/>
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Message Size"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Replay Detection"/>
<link href="#rfc.section.4" rel="Chapter" title="4 The DTLS Record Layer"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Sequence Number Handling"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Transport Layer Mapping"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 PMTU Issues"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Record Payload Protection"/>
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 Anti-Replay"/>
<link href="#rfc.section.4.4.2" rel="Chapter" title="4.4.2 Handling Invalid Records"/>
<link href="#rfc.section.5" rel="Chapter" title="5 The DTLS Handshake Protocol"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Denial-of-Service Countermeasures"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 DTLS Handshake Message Format"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 ACK Message"/>
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Handshake Message Fragmentation and Reassembly"/>
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Timeout and Retransmission"/>
<link href="#rfc.section.5.5.1" rel="Chapter" title="5.5.1 State Machine"/>
<link href="#rfc.section.5.5.2" rel="Chapter" title="5.5.2 Timer Values"/>
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 CertificateVerify and Finished Messages"/>
<link href="#rfc.section.5.7" rel="Chapter" title="5.7 Alert Messages"/>
<link href="#rfc.section.5.8" rel="Chapter" title="5.8 Establishing New Associations with Existing Parameters"/>
<link href="#rfc.section.5.9" rel="Chapter" title="5.9 Epoch Values and Rekeying"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Application Data Protocol"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Changes to DTLS 1.2"/>
<link href="#rfc.section.9" rel="Chapter" title="9 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="10 References"/>
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A History"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Working Group Information"/>
<link href="#rfc.appendix.C" rel="Chapter" title="C Contributors"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Rescorla, E., Tschofenig, H., and N. Modadugu" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-rescorla-tls-dtls13-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-4-28" />
  <meta name="dct.abstract" content="This document specifies Version 1.3 of the Datagram Transport Layer Security (DTLS) protocol. DTLS 1.3 allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery." />
  <meta name="description" content="This document specifies Version 1.3 of the Datagram Transport Layer Security (DTLS) protocol. DTLS 1.3 allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">TLS</td>
  <td class="right">E. Rescorla</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">RTFM, Inc.</td>
</tr>
<tr>
  <td class="left">Obsoletes: 6347 (if approved)</td>
  <td class="right">H. Tschofenig</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">ARM Limited</td>
</tr>
<tr>
  <td class="left">Expires: October 30, 2017</td>
  <td class="right">N. Modadugu</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">Google, Inc.</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">April 28, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">The Datagram Transport Layer Security (DTLS) Protocol Version 1.3<br />
  <span class="filename">draft-rescorla-tls-dtls13-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document specifies Version 1.3 of the Datagram Transport Layer Security (DTLS) protocol. DTLS 1.3 allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</p>
<p>The DTLS 1.3 protocol is intentionally based on the Transport Layer Security (TLS) 1.3 protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on October 30, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<p>This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008.  The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Conventions and Terminology</a></li>
<li>3.   <a href="#rfc.section.3">DTLS Design Rational and Overview</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Packet Loss</a></li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">Reordering</a></li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Message Size</a></li>
</ul><li>3.2.   <a href="#rfc.section.3.2">Replay Detection</a></li>
</ul><li>4.   <a href="#rfc.section.4">The DTLS Record Layer</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Sequence Number Handling</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Transport Layer Mapping</a></li>
<li>4.3.   <a href="#rfc.section.4.3">PMTU Issues</a></li>
<li>4.4.   <a href="#rfc.section.4.4">Record Payload Protection</a></li>
<ul><li>4.4.1.   <a href="#rfc.section.4.4.1">Anti-Replay</a></li>
<li>4.4.2.   <a href="#rfc.section.4.4.2">Handling Invalid Records</a></li>
</ul></ul><li>5.   <a href="#rfc.section.5">The DTLS Handshake Protocol</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Denial-of-Service Countermeasures</a></li>
<li>5.2.   <a href="#rfc.section.5.2">DTLS Handshake Message Format</a></li>
<li>5.3.   <a href="#rfc.section.5.3">ACK Message</a></li>
<li>5.4.   <a href="#rfc.section.5.4">Handshake Message Fragmentation and Reassembly</a></li>
<li>5.5.   <a href="#rfc.section.5.5">Timeout and Retransmission</a></li>
<ul><li>5.5.1.   <a href="#rfc.section.5.5.1">State Machine</a></li>
<li>5.5.2.   <a href="#rfc.section.5.5.2">Timer Values</a></li>
</ul><li>5.6.   <a href="#rfc.section.5.6">CertificateVerify and Finished Messages</a></li>
<li>5.7.   <a href="#rfc.section.5.7">Alert Messages</a></li>
<li>5.8.   <a href="#rfc.section.5.8">Establishing New Associations with Existing Parameters</a></li>
<li>5.9.   <a href="#rfc.section.5.9">Epoch Values and Rekeying</a></li>
</ul><li>6.   <a href="#rfc.section.6">Application Data Protocol</a></li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a></li>
<li>8.   <a href="#rfc.section.8">Changes to DTLS 1.2</a></li>
<li>9.   <a href="#rfc.section.9">IANA Considerations</a></li>
<li>10.   <a href="#rfc.references">References</a></li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">History</a></li>
<li>Appendix B.   <a href="#rfc.appendix.B">Working Group Information</a></li>
<li>Appendix C.   <a href="#rfc.appendix.C">Contributors</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">RFC EDITOR: PLEASE REMOVE THE FOLLOWING PARAGRAPH</p>
<p id="rfc.section.1.p.2">The source for this draft is maintained in GitHub. Suggested changes should be submitted as pull requests at https://github.com/tlswg/dtls13-spec.  Instructions are on that page as well. Editorial changes can be managed in GitHub, but any substantive change should be discussed on the TLS mailing list.</p>
<p id="rfc.section.1.p.3">The primary goal of the TLS protocol is to provide privacy and data integrity between two communicating peers. The TLS protocol is composed of two layers: the TLS Record Protocol and the TLS Handshake Protocol. However, TLS must run over a reliable transport channel &#8211; typically TCP <a href="#RFC0793">[RFC0793]</a>.</p>
<p id="rfc.section.1.p.4">There are applications that utilize UDP as a transport and to offer communication security protection for those applications the Datagram Transport Layer Security (DTLS) protocol has been designed. DTLS is deliberately designed to be as similar to TLS as possible, both to minimize new security invention and to maximize the amount of code and infrastructure reuse.</p>
<p id="rfc.section.1.p.5">DTLS 1.0 was originally defined as a delta from TLS 1.1 and DTLS 1.2 was defined as a series of deltas to TLS 1.2.  There is no DTLS 1.1; that version number was skipped in order to harmonize version numbers with TLS.  This specification describes the most current version of the DTLS protocol aligning with the efforts around TLS 1.3.</p>
<p id="rfc.section.1.p.6">Implementations that speak both DTLS 1.2 and DTLS 1.3 can interoperate with those that speak only DTLS 1.2 (using DTLS 1.2 of course), just as TLS 1.3 implementations can interoperate with TLS 1.2 (see Appendix D of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> for details). While backwards compatibility with DTLS 1.0 is possible the use of DTLS 1.0 is not recommended as explained in Section 3.1.2 of RFC 7525 <a href="#RFC7525">[RFC7525]</a>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#conventions-and-terminology" id="conventions-and-terminology">Conventions and Terminology</a></h1>
<p id="rfc.section.2.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.2.p.2">The following terms are used:</p>
<p/>

<ul>
  <li>client: The endpoint initiating the TLS connection.</li>
  <li>connection: A transport-layer connection between two endpoints.</li>
  <li>endpoint: Either the client or server of the connection.</li>
  <li>handshake: An initial negotiation between client and server that establishes the parameters of their transactions.</li>
  <li>peer: An endpoint. When discussing a particular endpoint, &#8220;peer&#8221; refers to the endpoint that is remote to the primary subject of discussion.</li>
  <li>receiver: An endpoint that is receiving records.</li>
  <li>sender: An endpoint that is transmitting records.</li>
  <li>session: An association between a client and a server resulting from a handshake.</li>
  <li>server: The endpoint which did not initiate the TLS connection.</li>
</ul>
<p id="rfc.section.2.p.4">The reader is assumed to be familiar with the TLS 1.3 specification since this document defined as a delta from TLS 1.3.</p>
<p id="rfc.section.2.p.5">Figures in this document illustrate various combinations of the DTLS protocol exchanges and the symbols have the following meaning:</p>
<p/>

<ul>
  <li>&#8217;+&#8217; indicates noteworthy extensions sent in the previously noted message.</li>
  <li>&#8216;*&#8217; indicates optional or situation-dependent messages/extensions that are not always sent.</li>
  <li>&#8217;{}&#8217; indicates messages protected using keys derived from a [sender]_handshake_traffic_secret.</li>
  <li>&#8217;[]&#8217; indicates messages protected using keysderived from traffic_secret_N.</li>
</ul>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#dtls-rational" id="dtls-rational">DTLS Design Rational and Overview</a></h1>
<p id="rfc.section.3.p.1">The basic design philosophy of DTLS is to construct &#8220;TLS over datagram transport&#8221;. Datagram transport does not require or provide reliable or in-order delivery of data.  The DTLS protocol preserves this property for application data.  Applications such as media streaming, Internet telephony, and online gaming use datagram transport for communication due to the delay-sensitive nature of transported data.  The behavior of such applications is unchanged when the DTLS protocol is used to secure communication, since the DTLS protocol does not compensate for lost or re-ordered data traffic.</p>
<p id="rfc.section.3.p.2">TLS cannot be used directly in datagram environments for the following five reasons:</p>
<p/>

<ol>
  <li>TLS does not allow independent decryption of individual records.  Because the integrity check indirectly depends on a sequence number, if record N is not received, then the integrity check on record N+1 will be based on the wrong sequence number and thus will fail. DTLS solves this problem by adding explicit sequence numbers.</li>
  <li>The TLS handshake is a lock-step cryptographic handshake.  Messages must be transmitted and received in a defined order; any other order is an error. Clearly, this is incompatible with reordering and message loss.</li>
  <li>Not all TLS 1.3 handshake messages (such as the NewSessionTicket message) are acknowledged. Hence, a new acknowledgement message has to be added to detect message loss.</li>
  <li>Handshake messages are potentially larger than any given datagram, thus creating the problem of IP fragmentation.</li>
  <li>Datagram transport protocols, like UDP, are more vulnerable to denial of service attacks and require a return-routability check with the help of cookies to be integrated into the handshake. A detailed discussion of countermeasures can be found in <a href="#dos">Section 5.1</a>.</li>
</ol>
<h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#packet-loss" id="packet-loss">Packet Loss</a></h2>
<p id="rfc.section.3.1.p.1">DTLS uses a simple retransmission timer to handle packet loss.  <a href="#dtls-retransmission">Figure 1</a> demonstrates the basic concept, using the first phase of the DTLS handshake:</p>
<div id="rfc.figure.1"/>
<div id="dtls-retransmission"/>
<pre>
         Client                                   Server
         ------                                   ------
         ClientHello           ------&gt;

                                 X&lt;-- HelloRetryRequest
                                                  (lost)

         [Timer Expires]

         ClientHello           ------&gt;
         (retransmit)
</pre>
<p class="figure">Figure 1: DTLS Retransmission Example.</p>
<p id="rfc.section.3.1.p.2">Once the client has transmitted the ClientHello message, it expects to see a HelloRetryRequest from the server.  However, if the server&#8217;s message is lost, the client knows that either the ClientHello or the HelloRetryRequest has been lost and retransmits.  When the server receives the retransmission, it knows to retransmit.</p>
<p id="rfc.section.3.1.p.3">The server also maintains a retransmission timer and retransmits when that timer expires.</p>
<p id="rfc.section.3.1.p.4">Note that timeout and retransmission do not apply to the HelloRetryRequest since this would require creating state on the server.  The HelloRetryRequest is designed to be small enough that it will not itself be fragmented, thus avoiding concerns about interleaving multiple HelloRetryRequests.</p>
<h3 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#reordering" id="reordering">Reordering</a></h3>
<p id="rfc.section.3.1.1.p.1">In DTLS, each handshake message is assigned a specific sequence number within that handshake.  When a peer receives a handshake message, it can quickly determine whether that message is the next message it expects.  If it is, then it processes it.  If not, it queues it for future handling once all previous messages have been received.</p>
<h3 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#message-size" id="message-size">Message Size</a></h3>
<p id="rfc.section.3.1.2.p.1">TLS and DTLS handshake messages can be quite large (in theory up to 2^24-1 bytes, in practice many kilobytes).  By contrast, UDP datagrams are often limited to less than 1500 bytes if IP fragmentation is not desired.  In order to compensate for this limitation, each DTLS handshake message may be fragmented over several DTLS records, each of which is intended to fit in a single IP datagram.  Each DTLS handshake message contains both a fragment offset and a fragment length.  Thus, a recipient in possession of all bytes of a handshake message can reassemble the original unfragmented message.</p>
<h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#replay-detection" id="replay-detection">Replay Detection</a></h2>
<p id="rfc.section.3.2.p.1">DTLS optionally supports record replay detection.  The technique used is the same as in IPsec AH/ESP, by maintaining a bitmap window of received records.  Records that are too old to fit in the window and records that have previously been received are silently discarded.  The replay detection feature is optional, since packet duplication is not always malicious, but can also occur due to routing errors.  Applications may conceivably detect duplicate packets and accordingly modify their data transmission strategy.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#the-dtls-record-layer" id="the-dtls-record-layer">The DTLS Record Layer</a></h1>
<p id="rfc.section.4.p.1">The DTLS record layer is similar to that of TLS 1.3 unless noted otherwise.  The only change is the inclusion of an explicit epoch and sequence number in the record.  This sequence number allows the recipient to correctly verify the TLS MAC.  The DTLS record format is shown below:</p>
<pre>
  struct {
       opaque content[DTLSPlaintext.length];
       ContentType type;
       uint8 zeros[length_of_padding];
   } DTLSInnerPlaintext;

   struct {
       ContentType opaque_type = 23; /* application_data */
       ProtocolVersion legacy_record_version = {254,253); // DTLSv1.2
       uint16 epoch;                         // DTLS-related field
       uint48 sequence_number;               // DTLS-related field
       uint16 length;
       opaque encrypted_record[length];
} DTLSCiphertext;
</pre>
<p/>

<dl>
  <dt>type:</dt>
  <dd style="margin-left: 8">The content type of the record.</dd>
  <dt>legacy_record_version:</dt>
  <dd style="margin-left: 8">This field is redundant and it is treated in the same way as specified in the TLS 1.3 specification. The DTLS version 1.2 version number is reused, namely { 254, 253 }. This field is deprecated and MUST be ignored.</dd>
  <dt>epoch:</dt>
  <dd style="margin-left: 8">A counter value that is incremented on every cipher state change.</dd>
  <dt>sequence_number:</dt>
  <dd style="margin-left: 8">The sequence number for this record.</dd>
  <dt>length:</dt>
  <dd style="margin-left: 8">Identical to the length field in a TLS 1.3 record.</dd>
  <dt>encrypted_record:</dt>
  <dd style="margin-left: 8">Identical to the encrypted_record field in a TLS 1.3 record.</dd>
</dl>
<h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#sequence-number-handling" id="sequence-number-handling">Sequence Number Handling</a></h2>
<p id="rfc.section.4.1.p.1">DTLS uses an explicit sequence number, rather than an implicit one, carried in the sequence_number field of the record.  Sequence numbers are maintained separately for each epoch, with each sequence_number initially being 0 for each epoch.  For instance, if a handshake message from epoch 0 is retransmitted, it might have a sequence number after a message from epoch 1, even if the message from epoch 1 was transmitted first.  Note that some care needs to be taken during the handshake to ensure that retransmitted messages use the right epoch and keying material.</p>
<p id="rfc.section.4.1.p.2">The epoch number is initially zero and is incremented each time keying material changes and a sender aims to rekey.  More details are provided in <a href="#dtls-epoch">Section 5.9</a>. In order to ensure that any given sequence/epoch pair is unique, implementations MUST NOT allow the same epoch value to be reused within two times the TCP maximum segment lifetime.</p>
<p id="rfc.section.4.1.p.3">Note that because DTLS records may be reordered, a record from epoch 1 may be received after epoch 2 has begun.  In general, implementations SHOULD discard packets from earlier epochs, but if packet loss causes noticeable problems they MAY choose to retain keying material from previous epochs for up to the default MSL specified for TCP <a href="#RFC0793">[RFC0793]</a> to allow for packet reordering.  (Note that the intention here is that implementers use the current guidance from the IETF for MSL, not that they attempt to interrogate the MSL that the system TCP stack is using.)  Until the handshake has completed, implementations MUST accept packets from the old epoch.</p>
<p id="rfc.section.4.1.p.4">Conversely, it is possible for records that are protected by the newly negotiated context to be received prior to the completion of a handshake.  For instance, the server may send its Finished message and then start transmitting data.  Implementations MAY either buffer or discard such packets, though when DTLS is used over reliable transports (e.g., SCTP), they SHOULD be buffered and processed once the handshake completes.  Note that TLS&#8217;s restrictions on when packets may be sent still apply, and the receiver treats the packets as if they were sent in the right order.  In particular, it is still impermissible to send data prior to completion of the first handshake.</p>
<p id="rfc.section.4.1.p.5">Implementations MUST either abandon an association or re-key prior to allowing the sequence number to wrap.</p>
<p id="rfc.section.4.1.p.6">Implementations MUST NOT allow the epoch to wrap, but instead MUST establish a new association, terminating the old association.</p>
<h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#transport-layer-mapping" id="transport-layer-mapping">Transport Layer Mapping</a></h2>
<p id="rfc.section.4.2.p.1">Each DTLS record MUST fit within a single datagram.  In order to avoid IP fragmentation, clients of the DTLS record layer SHOULD attempt to size records so that they fit within any PMTU estimates obtained from the record layer.</p>
<p id="rfc.section.4.2.p.2">Note that unlike IPsec, DTLS records do not contain any association identifiers.  Applications must arrange to multiplex between associations.   With UDP, the host/port number is used to look up the appropriate security association for incoming records.</p>
<p id="rfc.section.4.2.p.3">Multiple DTLS records may be placed in a single datagram.  They are simply encoded consecutively.  The DTLS record framing is sufficient to determine the boundaries.  Note, however, that the first byte of the datagram payload must be the beginning of a record.  Records may not span datagrams.</p>
<p id="rfc.section.4.2.p.4">Some transports, such as DCCP <a href="#RFC4340">[RFC4340]</a>, provide their own sequence numbers.  When carried over those transports, both the DTLS and the transport sequence numbers will be present.  Although this introduces a small amount of inefficiency, the transport layer and DTLS sequence numbers serve different purposes; therefore, for conceptual simplicity, it is superior to use both sequence numbers.</p>
<p id="rfc.section.4.2.p.5">Some transports provide congestion control for traffic carried over them.  If the congestion window is sufficiently narrow, DTLS handshake retransmissions may be held rather than transmitted immediately, potentially leading to timeouts and spurious retransmission.  When DTLS is used over such transports, care should be taken not to overrun the likely congestion window. <a href="#RFC5238">[RFC5238]</a> defines a mapping of DTLS to DCCP that takes these issues into account.</p>
<h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#pmtu-issues" id="pmtu-issues">PMTU Issues</a></h2>
<p id="rfc.section.4.3.p.1">In general, DTLS&#8217;s philosophy is to leave PMTU discovery to the application.  However, DTLS cannot completely ignore PMTU for three reasons:</p>
<p/>

<ul>
  <li>The DTLS record framing expands the datagram size, thus lowering the effective PMTU from the application&#8217;s perspective.</li>
  <li>In some implementations, the application may not directly talk to the network, in which case the DTLS stack may absorb ICMP <a href="#RFC1191">[RFC1191]</a> &#8220;Datagram Too Big&#8221; indications or ICMPv6 <a href="#RFC4443">[RFC4443]</a> &#8220;Packet Too Big&#8221; indications.</li>
  <li>The DTLS handshake messages can exceed the PMTU.</li>
</ul>
<p id="rfc.section.4.3.p.3">In order to deal with the first two issues, the DTLS record layer SHOULD behave as described below.</p>
<p id="rfc.section.4.3.p.4">If PMTU estimates are available from the underlying transport protocol, they should be made available to upper layer protocols.  In particular:</p>
<p/>

<ul>
  <li>For DTLS over UDP, the upper layer protocol SHOULD be allowed to obtain the PMTU estimate maintained in the IP layer.</li>
  <li>For DTLS over DCCP, the upper layer protocol SHOULD be allowed to obtain the current estimate of the PMTU.</li>
  <li>For DTLS over TCP or SCTP, which automatically fragment and reassemble datagrams, there is no PMTU limitation.  However, the upper layer protocol MUST NOT write any record that exceeds the maximum record size of 2^14 bytes.</li>
</ul>
<p id="rfc.section.4.3.p.6">The DTLS record layer SHOULD allow the upper layer protocol to discover the amount of record expansion expected by the DTLS processing.</p>
<p id="rfc.section.4.3.p.7">If there is a transport protocol indication (either via ICMP or via a refusal to send the datagram as in Section 14 of <a href="#RFC4340">[RFC4340]</a>), then the DTLS record layer MUST inform the upper layer protocol of the error.</p>
<p id="rfc.section.4.3.p.8">The DTLS record layer SHOULD NOT interfere with upper layer protocols performing PMTU discovery, whether via <a href="#RFC1191">[RFC1191]</a> or <a href="#RFC4821">[RFC4821]</a> mechanisms.  In particular:</p>
<p/>

<ul>
  <li>Where allowed by the underlying transport protocol, the upper layer protocol SHOULD be allowed to set the state of the DF bit (in IPv4) or prohibit local fragmentation (in IPv6).</li>
  <li>If the underlying transport protocol allows the application to request PMTU probing (e.g., DCCP), the DTLS record layer should honor this request.</li>
</ul>
<p id="rfc.section.4.3.p.10">The final issue is the DTLS handshake protocol.  From the perspective of the DTLS record layer, this is merely another upper layer protocol.  However, DTLS handshakes occur infrequently and involve only a few round trips; therefore, the handshake protocol PMTU handling places a premium on rapid completion over accurate PMTU discovery.  In order to allow connections under these circumstances, DTLS implementations SHOULD follow the following rules:</p>
<p/>

<ul>
  <li>If the DTLS record layer informs the DTLS handshake layer that a message is too big, it SHOULD immediately attempt to fragment it, using any existing information about the PMTU.</li>
  <li>If repeated retransmissions do not result in a response, and the PMTU is unknown, subsequent retransmissions SHOULD back off to a smaller record size, fragmenting the handshake message as appropriate.  This standard does not specify an exact number of retransmits to attempt before backing off, but 2-3 seems appropriate.</li>
</ul>
<h2 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#record-payload-protection" id="record-payload-protection">Record Payload Protection</a></h2>
<p id="rfc.section.4.4.p.1">Like TLS, DTLS transmits data as a series of protected records.  The rest of this section describes the details of that format.</p>
<h3 id="rfc.section.4.4.1"><a href="#rfc.section.4.4.1">4.4.1.</a> <a href="#anti-replay" id="anti-replay">Anti-Replay</a></h3>
<p id="rfc.section.4.4.1.p.1">DTLS records contain a sequence number to provide replay protection.  Sequence number verification SHOULD be performed using the following sliding window procedure, borrowed from Section 3.4.3 of <a href="#RFC4303">[RFC4303]</a>.</p>
<p id="rfc.section.4.4.1.p.2">The receiver packet counter for this session MUST be initialized to zero when the session is established.  For each received record, the receiver MUST verify that the record contains a sequence number that does not duplicate the sequence number of any other record received during the life of this session.  This SHOULD be the first check applied to a packet after it has been matched to a session, to speed rejection of duplicate records.</p>
<p id="rfc.section.4.4.1.p.3">Duplicates are rejected through the use of a sliding receive window.  (How the window is implemented is a local matter, but the following text describes the functionality that the implementation must exhibit.)  A minimum window size of 32 MUST be supported, but a window size of 64 is preferred and SHOULD be employed as the default.  Another window size (larger than the minimum) MAY be chosen by the receiver.  (The receiver does not notify the sender of the window size.)</p>
<p id="rfc.section.4.4.1.p.4">The &#8220;right&#8221; edge of the window represents the highest validated sequence number value received on this session.  Records that contain sequence numbers lower than the &#8220;left&#8221; edge of the window are rejected.  Packets falling within the window are checked against a list of received packets within the window.  An efficient means for performing this check, based on the use of a bit mask, is described in Section 3.4.3 of <a href="#RFC4303">[RFC4303]</a>.</p>
<p id="rfc.section.4.4.1.p.5">If the received record falls within the window and is new, or if the packet is to the right of the window, then the receiver proceeds to MAC verification.  If the MAC validation fails, the receiver MUST discard the received record as invalid.  The receive window is updated only if the MAC verification succeeds.</p>
<h3 id="rfc.section.4.4.2"><a href="#rfc.section.4.4.2">4.4.2.</a> <a href="#handling-invalid-records" id="handling-invalid-records">Handling Invalid Records</a></h3>
<p id="rfc.section.4.4.2.p.1">Unlike TLS, DTLS is resilient in the face of invalid records (e.g., invalid formatting, length, MAC, etc.).  In general, invalid records SHOULD be silently discarded, thus preserving the association; however, an error MAY be logged for diagnostic purposes.  Implementations which choose to generate an alert instead, MUST generate error alerts to avoid attacks where the attacker repeatedly probes the implementation to see how it responds to various types of error.  Note that if DTLS is run over UDP, then any implementation which does this will be extremely susceptible to denial-of-service (DoS) attacks because UDP forgery is so easy.  Thus, this practice is NOT RECOMMENDED for such transports.</p>
<p id="rfc.section.4.4.2.p.2">If DTLS is being carried over a transport that is resistant to forgery (e.g., SCTP with SCTP-AUTH), then it is safer to send alerts because an attacker will have difficulty forging a datagram that will not be rejected by the transport layer.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#dtls" id="dtls">The DTLS Handshake Protocol</a></h1>
<p id="rfc.section.5.p.1">DTLS 1.3 re-uses the TLS 1.3 handshake messages and flows, with the following changes:</p>
<p/>

<ol>
  <li>To handle message loss, reordering, and fragmentation modifications to the handshake header are necessary.</li>
  <li>Retransmission timers are introduced to handle message loss.</li>
  <li>The TLS 1.3 KeyUpdate message is not used in DTLS 1.3 for re-keying.</li>
  <li>A new ACK message has been added for reliable message delivery of certain handshake messages.</li>
</ol>
<p id="rfc.section.5.p.3">Note that TLS 1.3 already supports a cookie extension, which used to prevent denial-of-service attacks. This DoS prevention mechanism is described in more detail below since UDP-based protocols are more vulnerable to amplification attacks than a connection-oriented transport like TCP that performs return-routability checks as part of the connection establishment.</p>
<p id="rfc.section.5.p.4">With these exceptions, the DTLS message formats, flows, and logic are the same as those of TLS 1.3.</p>
<h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#dos" id="dos">Denial-of-Service Countermeasures</a></h2>
<p id="rfc.section.5.1.p.1">Datagram security protocols are extremely susceptible to a variety of DoS attacks.  Two attacks are of particular concern:</p>
<p/>

<ol>
  <li>An attacker can consume excessive resources on the server by transmitting a series of handshake initiation requests, causing the server to allocate state and potentially to perform expensive cryptographic operations.</li>
  <li>An attacker can use the server as an amplifier by sending connection initiation messages with a forged source of the victim.  The server then sends its response to the victim machine, thus flooding it. Depending on the selected ciphersuite this response message can be quite large, as it is the case for a Certificate message.</li>
</ol>
<p id="rfc.section.5.1.p.3">In order to counter both of these attacks, DTLS borrows the stateless cookie technique used by Photuris <a href="#RFC2522">[RFC2522]</a> and IKE <a href="#RFC5996">[RFC5996]</a>.  When the client sends its ClientHello message to the server, the server MAY respond with a HelloRetryRequest message. The HelloRetryRequest message, as well as the cookie extension, is defined in TLS 1.3. The HelloRetryRequest message contains a stateless cookie generated using the technique of <a href="#RFC2522">[RFC2522]</a>. The client MUST retransmit the ClientHello with the cookie added as an extension.  The server then verifies the cookie and proceeds with the handshake only if it is valid.  This mechanism forces the attacker/client to be able to receive the cookie, which makes DoS attacks with spoofed IP addresses difficult.  This mechanism does not provide any defence against DoS attacks mounted from valid IP addresses.</p>
<p id="rfc.section.5.1.p.4">The DTLS 1.3 specification changes the way how cookies are exchanged compared to DTLS 1.2. DTLS 1.3 re-uses the HelloRetryRequest message and conveys the cookie to the client via an extension. The client receiving the cookie uses the same extension to place the cookie subsequently into a ClientHello message.<br/> DTLS 1.2 on the other hand used a separate message, namely the HelloVerifyRequest, to pass a cookie to the client and did not utilize the extension mechanism.  For backwards compatibility reason the cookie field in the ClientHello is present in DTLS 1.3 but is ignored by a DTLS 1.3 compliant server implementation.</p>
<p id="rfc.section.5.1.p.5">The exchange is shown in <a href="#dtls-cookie-exchange">Figure 2</a>. Note that the figure focuses on the cookie exchange; all other extensions are omitted.</p>
<div id="rfc.figure.2"/>
<div id="dtls-cookie-exchange"/>
<pre>
      Client                                   Server
      ------                                   ------
      ClientHello           ------&gt;

                            &lt;----- HelloRetryRequest
                                    + cookie

      ClientHello           ------&gt;
       + cookie

      [Rest of handshake]
</pre>
<p class="figure">Figure 2: DTLS Exchange with HelloRetryRequest contain the Cookie Extension</p>
<p id="rfc.section.5.1.p.6">The cookie extension is defined in Section 4.2.2 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>. When sending the initial ClientHello, the client does not have a cookie yet. In this case, the cookie extension is omitted and the legacy_cookie field in the ClientHello message SHOULD be set to a zero length vector (i.e., a single zero byte length field) and MUST be ignored by a server negotiating DTLS 1.3.</p>
<p id="rfc.section.5.1.p.7">When responding to a HelloRetryRequest, the client MUST create a new ClientHello message following the description in Section 4.1.2 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>.</p>
<p id="rfc.section.5.1.p.8">The server SHOULD use information received in the ClientHello to generate its cookie, such as version, random, ciphersuites. The server MUST use the same version number in the HelloRetryRequest that it would use when sending a ServerHello.  Upon receipt of the ServerHello, the client MUST verify that the server version values match and MUST terminate the connection with an &#8220;illegal_parameter&#8221; alert otherwise.</p>
<p id="rfc.section.5.1.p.9">If the HelloRetryRequest message is used, the initial ClientHello and the HelloRetryRequest are included in the calculation of the handshake_messages (for the CertificateVerify message) and verify_data (for the Finished message).  However, the computation of the message hash for the HelloRetryRequest is done according to the description in Section 4.4.1 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>.</p>
<p id="rfc.section.5.1.p.10">The handshake transcript is not reset with the second ClientHello and a stateless server-cookie implementation requires the transcript of the HelloRetryRequest to be stored in the cookie or the internal state of the hash algorithm, since only the hash of the transcript is required for the handshake to complete.</p>
<p id="rfc.section.5.1.p.11">When the second ClientHello is received, the server can verify that the cookie is valid and that the client can receive packets at the given IP address.</p>
<p id="rfc.section.5.1.p.12">One potential attack on this scheme is for the attacker to collect a number of cookies from different addresses and then reuse them to attack the server. The server can defend against this attack by changing the secret value frequently, thus invalidating those cookies. If the server wishes that legitimate clients be able to handshake through the transition (e.g., they received a cookie with Secret 1 and then sent the second ClientHello after the server has changed to Secret 2), the server can have a limited window during which it accepts both secrets.  <a href="#RFC5996">[RFC5996]</a> suggests adding a key identifier to cookies to detect this case. An alternative approach is simply to try verifying with both secrets. It is RECOMMENDED that servers implement a key rotation scheme that allows the server to manage keys with overlapping lifetime.</p>
<p id="rfc.section.5.1.p.13">Alternatively, the server can store timestamps in the cookie and reject those cookies that were not generated within a certain amount of time.</p>
<p id="rfc.section.5.1.p.14">DTLS servers SHOULD perform a cookie exchange whenever a new handshake is being performed.  If the server is being operated in an environment where amplification is not a problem, the server MAY be configured not to perform a cookie exchange.  The default SHOULD be that the exchange is performed, however.  In addition, the server MAY choose not to do a cookie exchange when a session is resumed.  Clients MUST be prepared to do a cookie exchange with every handshake.</p>
<p id="rfc.section.5.1.p.15">If a server receives a ClientHello with an invalid cookie, it MUST NOT respond with a HelloRetryRequest. Restarting the handshake from scratch, without a cookie, allows the client to recover from a situation where it obtained a cookie that cannot be verified by the server.  As described in Section 4.1.4 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>,clients SHOULD also abort the handshake with an &#8220;unexpected_message&#8221; alert in response to any second HelloRetryRequest which was sent in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest).</p>
<h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#dtls-handshake-message-format" id="dtls-handshake-message-format">DTLS Handshake Message Format</a></h2>
<p id="rfc.section.5.2.p.1">In order to support message loss, reordering, and message fragmentation, DTLS modifies the TLS 1.3 handshake header:</p>
<pre>
  enum {
      hello_request_RESERVED(0),
      client_hello(1),
      server_hello(2),
      hello_verify_request_RESERVED(3),
      new_session_ticket(4),
      end_of_early_data(5),      
      hello_retry_request(6),
      encrypted_extensions(8),
      certificate(11),
      server_key_exchange_RESERVED(12),
      certificate_request(13),
      server_hello_done_RESERVED(14),
      certificate_verify(15),
      client_key_exchange_RESERVED(16),
      finished(20),
      key_update_RESERVED(24),
      ack([[TBD RFC Editor -- Proposal: 25]]), 
      message_hash(254),
      (255)
  } HandshakeType;

  struct {
      HandshakeType msg_type;    /* handshake type */
      uint24 length;             /* bytes in message */
      uint16 message_seq;        /* DTLS-required field */
      uint24 fragment_offset;    /* DTLS-required field */
      uint24 fragment_length;    /* DTLS-required field */      
      select (HandshakeType) {
          case client_hello:          ClientHello;
          case server_hello:          ServerHello;
          case end_of_early_data:     EndOfEarlyData;
          case hello_retry_request:   HelloRetryRequest;
          case encrypted_extensions:  EncryptedExtensions;
          case certificate_request:   CertificateRequest;
          case certificate:           Certificate;
          case certificate_verify:    CertificateVerify;
          case finished:              Finished;
          case new_session_ticket:    NewSessionTicket;
          case key_update:            KeyUpdate; /* reserved */
          case ack:                   ACK; /* DTLS-required field */
      } body;
  } Handshake;
</pre>
<p id="rfc.section.5.2.p.2">In addition to the handshake messages that are deprecated by the TLS 1.3 specification DTLS 1.3 furthermore deprecates the HelloVerifyRequest message originally defined in DTLS 1.0. DTLS 1.3-compliant implements MUST NOT use the HelloVerifyRequest to execute a return-routability check. A dual-stack DTLS 1.2/DTLS 1.3 client MUST, however, be prepared to interact with a DTLS 1.2 server.</p>
<p id="rfc.section.5.2.p.3">A DTLS 1.3 MUST NOT use the KeyUpdate message to change keying material used for the protection of traffic data. Instead the epoch field is used, which is explained in <a href="#dtls-epoch">Section 5.9</a>.</p>
<p id="rfc.section.5.2.p.4">The format of the ClientHello used by a DTLS 1.3 client differs from the TLS 1.3 ClientHello format as shown below.</p>
<pre>
   uint16 ProtocolVersion;
   opaque Random[32];

   uint8 CipherSuite[2];    /* Cryptographic suite selector */

   struct {
       ProtocolVersion legacy_version = { 254,253 }; // DTLSv1.2
       Random random;
       opaque legacy_session_id&lt;0..32&gt;;
       opaque legacy_cookie&lt;0..2^8-1&gt;;                  // DTLS
       CipherSuite cipher_suites&lt;2..2^16-2&gt;;
       opaque legacy_compression_methods&lt;1..2^8-1&gt;;
       Extension extensions&lt;0..2^16-1&gt;;
   } ClientHello;
</pre>
<p/>

<dl>
  <dt>legacy_version:</dt>
  <dd style="margin-left: 8">In previous versions of DTLS, this field was used for version negotiation and represented the highest version number supported by the client. Experience has shown that many servers do not properly implement version negotiation, leading to &#8220;version intolerance&#8221; in which the server rejects an otherwise acceptable ClientHello with a version number higher than it supports. In DTLS 1.3, the client indicates its version preferences in the &#8220;supported_versions&#8221; extension (see Section 4.2.1 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>) and the legacy_version field MUST be set to {254, 253}, which was the version number for DTLS 1.2.</dd>
  <dt>random:</dt>
  <dd style="margin-left: 8">Same as for TLS 1.3</dd>
  <dt>legacy_session_id:</dt>
  <dd style="margin-left: 8">Same as for TLS 1.3</dd>
  <dt>legacy_cookie:</dt>
  <dd style="margin-left: 8">A DTLS 1.3-only client MUST set the legacy_cookie field to zero length.</dd>
  <dt>cipher_suites:</dt>
  <dd style="margin-left: 8">Same as for TLS 1.3</dd>
  <dt>legacy_compression_methods:</dt>
  <dd style="margin-left: 8">Same as for TLS 1.3</dd>
  <dt>extensions:</dt>
  <dd style="margin-left: 8">Same as for TLS 1.3</dd>
</dl>
<p id="rfc.section.5.2.p.6">The first message each side transmits in each handshake always has message_seq = 0.  Whenever a new message is generated, the message_seq value is incremented by one. When a message is retransmitted, the old message_seq value is re-used, i.e., not incremented.</p>
<p id="rfc.section.5.2.p.7">Here is an example:</p>
<div id="rfc.figure.3"/>
<div id="dtls-msg-loss"/>
<pre>
Client                                             Server
------                                             ------

ClientHello 
(message_seq=0)
                             --------&gt;

                                X&lt;----      HelloRetryRequest 
                                (lost)        (message_seq=0)
                                                  

[Timer Expires]

ClientHello
(message_seq=0)
 (retransmit)               --------&gt;


                            &lt;--------       HelloRetryRequest
                                              (message_seq=0)

ClientHello                 --------&gt;
(message_seq=1)
  +cookie

                            &lt;--------             ServerHello
                                              (message_seq=1)
                                          EncryptedExtensions
                                              (message_seq=2)
                                                  Certificate 
                                              (message_seq=3)
                                            CertificateVerify 
                                              (message_seq=4)
                                                     Finished
                                              (message_seq=5)

Certificate                --------&gt;
(message_seq=2)
CertificateVerify
(message_seq=3)
Finished 
(message_seq=4)

                        &lt;--------                         Ack 
                                              (message_seq=6)
</pre>
<p class="figure">Figure 3: Example DTLS Exchange illustrating Message Loss</p>
<p id="rfc.section.5.2.p.8">From the perspective of the DTLS record layer, the retransmission is a new record.  This record will have a new DTLSPlaintext.sequence_number value.</p>
<p id="rfc.section.5.2.p.9">DTLS implementations maintain (at least notionally) a next_receive_seq counter.  This counter is initially set to zero.  When a message is received, if its sequence number matches next_receive_seq, next_receive_seq is incremented and the message is processed.  If the sequence number is less than next_receive_seq, the message MUST be discarded.  If the sequence number is greater than next_receive_seq, the implementation SHOULD queue the message but MAY discard it.  (This is a simple space/bandwidth tradeoff).</p>
<h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#ack-msg" id="ack-msg">ACK Message</a></h2>
<pre>
struct {} ACK;
</pre>
<p id="rfc.section.5.3.p.1">The ACK handshake message is used by an endpoint to respond to a message where the TLS 1.3 handshake does not foresee such return message. With the use of the ACK message the sender is able to determine whether a transmitted request has been lost and needs to be retransmitted. Since the ACK message does not contain any correlation information the sender MUST only have one such message outstanding at a time.</p>
<p id="rfc.section.5.3.p.2">The ACK message uses a handshake content type and is encrypted under the appropriate application traffic key.  [[OPEN ISSUE: It seems odd to have the ACK that responds to CFIN encrypted under the application key. Also, what do you do about ACKs that have to deal with key changes.]]</p>
<h2 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a> <a href="#handshake-message-fragmentation-and-reassembly" id="handshake-message-fragmentation-and-reassembly">Handshake Message Fragmentation and Reassembly</a></h2>
<p id="rfc.section.5.4.p.1">Each DTLS message MUST fit within a single transport layer datagram.  However, handshake messages are potentially bigger than the maximum record size.  Therefore, DTLS provides a mechanism for fragmenting a handshake message over a number of records, each of which can be transmitted separately, thus avoiding IP fragmentation.</p>
<p id="rfc.section.5.4.p.2">When transmitting the handshake message, the sender divides the message into a series of N contiguous data ranges.  These ranges MUST NOT be larger than the maximum handshake fragment size and MUST jointly contain the entire handshake message.  The ranges MUST NOT overlap.  The sender then creates N handshake messages, all with the same message_seq value as the original handshake message.  Each new message is labeled with the fragment_offset (the number of bytes contained in previous fragments) and the fragment_length (the length of this fragment).  The length field in all messages is the same as the length field of the original message.  An unfragmented message is a degenerate case with fragment_offset=0 and fragment_length=length.</p>
<p id="rfc.section.5.4.p.3">When a DTLS implementation receives a handshake message fragment, it MUST buffer it until it has the entire handshake message.  DTLS implementations MUST be able to handle overlapping fragment ranges.  This allows senders to retransmit handshake messages with smaller fragment sizes if the PMTU estimate changes.</p>
<p id="rfc.section.5.4.p.4">Note that as with TLS, multiple handshake messages may be placed in the same DTLS record, provided that there is room and that they are part of the same flight.  Thus, there are two acceptable ways to pack two DTLS messages into the same datagram: in the same record or in separate records.</p>
<h2 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a> <a href="#timeout-and-retransmission" id="timeout-and-retransmission">Timeout and Retransmission</a></h2>
<p id="rfc.section.5.5.p.1">DTLS messages are grouped into a series of message flights, according to the diagrams below.  Although each flight of messages may consist of a number of messages, they should be viewed as monolithic for the purpose of timeout and retransmission.</p>
<div id="rfc.figure.4"/>
<div id="dtls-full"/>
<pre>
Client                                             Server

ClientHello                                                 +----------+
 + key_share*                                               | Flight 1 |
 + pre_shared_key*      --------&gt;                           +----------+

                                                            +----------+
                        &lt;--------        HelloRetryRequest  | Flight 2 |
                                          + cookie          +----------+


ClientHello                                                 +----------+
 + key_share*                                               | Flight 3 |
 + pre_shared_key*      --------&gt;                           +----------+
 + cookie

                                               ServerHello
                                              + key_share*
                                         + pre_shared_key*  +----------+
                                     {EncryptedExtensions}  | Flight 4 |
                                     {CertificateRequest*}  +----------+
                                            {Certificate*}
                                      {CertificateVerify*}
                        &lt;--------               {Finished}
                                       [Application Data*]


 {Certificate*}                                             +----------+
 {CertificateVerify*}                                       | Flight 5 |
 {Finished}             --------&gt;                           +----------+
 [Application Data]

                                                            +----------+
                        &lt;--------                    [Ack]  | Flight 6 |
                                       [Application Data*]  +----------+

 [Application Data]     &lt;-------&gt;      [Application Data]
</pre>
<p class="figure">Figure 4: Message Flights for full DTLS Handshake (with Cookie Exchange)</p>
<div id="rfc.figure.5"/>
<div id="dtls-psk"/>
<pre>
 ClientHello                                              +----------+
  + pre_shared_key                                        | Flight 1 |
  + key_share*         --------&gt;                          +----------+


                                             ServerHello
                                        + pre_shared_key  +----------+
                                            + key_share*  | Flight 2 |
                                   {EncryptedExtensions}  +----------+
                       &lt;--------              {Finished}
                                     [Application Data*]
                                                          +----------+
 {Finished}            --------&gt;                          | Flight 3 |
 [Application Data*]                                      +----------+

                                                          +----------+
                       &lt;--------                   [Ack]  | Flight 4 |
                                     [Application Data*]  +----------+

 [Application Data]    &lt;-------&gt;      [Application Data]
</pre>
<p class="figure">Figure 5: Message Flights for Resumption and PSK Handshake (without Cookie Exchange)</p>
<div id="rfc.figure.6"/>
<div id="dtls-zero-rtt"/>
<pre>
Client                                            Server

ClientHello
  + early_data
  + psk_key_exchange_modes                                +----------+
  + key_share*                                            | Flight 1 |
  + pre_shared_key                                        +----------+
(Application Data*)     --------&gt;

                                             ServerHello
                                        + pre_shared_key
                                            + key_share*  +----------+
                                   {EncryptedExtensions}  | Flight 2 |
                                              {Finished}  +----------+
                       &lt;--------     [Application Data*]
                                      

                                                          +----------+
 (EndOfEarlyData)                                         | Flight 3 |
 {Finished}            --------&gt;                          +----------+ 
 [Application Data*]
                                                          +----------+
                       &lt;--------                   [Ack]  | Flight 4 |
                                     [Application Data*]  +----------+

 [Application Data]    &lt;-------&gt;      [Application Data]
</pre>
<p class="figure">Figure 6: Message Flights for the Zero-RTT Handshake</p>
<div id="rfc.figure.7"/>
<div id="dtls-post-handshake-ticket"/>
<pre>
Client                                            Server

                                                          +----------+
                       &lt;--------       [NewSessionTicket] | Flight 1 |
                                                          +----------+

                                                          +----------+
[Ack]                  --------&gt;                          | Flight 2 |
                                                          +----------+
</pre>
<p class="figure">Figure 7: Message Flights for New Session Ticket Message</p>
<div id="rfc.figure.8"/>
<div id="dtls-post-handshake-auth-success"/>
<pre>
Client                                            Server

                                                          +----------+
                       &lt;--------     [CertificateRequest] | Flight 1 |
                                                          +----------+

[Certificate]                                             +----------+
[CertificateVerify]                                       | Flight 2 |
[Finished]             --------&gt;                          +----------+
</pre>
<p class="figure">Figure 8: Message Flights for Post-Handshake Authentication (Success)</p>
<div id="rfc.figure.9"/>
<div id="dtls-post-handshake-auth-failure"/>
<pre>
Client                                            Server

                                                          +----------+
                       &lt;--------     [CertificateRequest] | Flight 1 |
                                                          +----------+

[Certificate]                                             +----------+
[Finished]             --------&gt;                          | Flight 2 |
                                                          +----------+
</pre>
<p class="figure">Figure 9: Message Flights for Post-Handshake Authentication (Decline)</p>
<p id="rfc.section.5.5.p.2">Note: The application data sent by the client is not included in the timeout and retransmission calculation.</p>
<h3 id="rfc.section.5.5.1"><a href="#rfc.section.5.5.1">5.5.1.</a> <a href="#state-machine" id="state-machine">State Machine</a></h3>
<p id="rfc.section.5.5.1.p.1">DTLS uses a simple timeout and retransmission scheme with the state machine shown in <a href="#dtls-timeout-state-machine">Figure 10</a>.  Because DTLS clients send the first message (ClientHello), they start in the PREPARING state.  DTLS servers start in the WAITING state, but with empty buffers and no retransmit timer.</p>
<div id="rfc.figure.10"/>
<div id="dtls-timeout-state-machine"/>
<pre>
                      +-----------+
                      | PREPARING |
                +---&gt; |           | 
                |     |           |                      
                |     +-----------+                      
                |           |                            
                |           | Buffer next flight         
                |           |                            
                |          \|/                           
                |     +-----------+                      
                |     |           |                      
                |     |  SENDING  |&lt;------------------+  
                |     |           |                   |  
                |     +-----------+                   |  
        Receive |           |                         |  
           next |           | Send flight             |  
         flight |  +--------+                         |  
                |  |        | Set retransmit timer    |  
                |  |       \|/                        |  
                |  |  +-----------+                   |  
                |  |  |           |                   |  
                +--)--|  WAITING  |-------------------+  
                |  |  |           |   Timer expires   |  
                |  |  +-----------+                   |  
                |  |         |                        |  
                |  |         |                        |  
                |  |         +------------------------+  
                |  |                Read retransmit      
        Receive |  |                                     
           last |  |                                     
         flight |  |                                     
                |  |                                     
               \|/\|/                                    
                                                         
            +-----------+                                
            |           |                                
            | FINISHED  |
            |           |
            +-----------+
                |  /|\
                |   |
                |   |
                +---+

          Server read retransmit
              Retransmit ACK
</pre>
<p class="figure">Figure 10: DTLS Timeout and Retransmission State Machine</p>
<p id="rfc.section.5.5.1.p.2">The state machine has three basic states.</p>
<p id="rfc.section.5.5.1.p.3">In the PREPARING state, the implementation does whatever computations are necessary to prepare the next flight of messages.  It then buffers them up for transmission (emptying the buffer first) and enters the SENDING state.</p>
<p id="rfc.section.5.5.1.p.4">In the SENDING state, the implementation transmits the buffered flight of messages.  Once the messages have been sent, the implementation then enters the FINISHED state if this is the last flight in the handshake.  Or, if the implementation expects to receive more messages, it sets a retransmit timer and then enters the WAITING state.</p>
<p id="rfc.section.5.5.1.p.5">There are three ways to exit the WAITING state:</p>
<p/>

<ol>
  <li>The retransmit timer expires: the implementation transitions to the SENDING state, where it retransmits the flight, resets the retransmit timer, and returns to the WAITING state.</li>
  <li>The implementation reads a retransmitted flight from the peer: the implementation transitions to the SENDING state, where it retransmits the flight, resets the retransmit timer, and returns to the WAITING state.  The rationale here is that the receipt of a duplicate message is the likely result of timer expiry on the peer and therefore suggests that part of one&#8217;s previous flight was lost.</li>
  <li>The implementation receives the next flight of messages: if this is the final flight of messages, the implementation transitions to FINISHED.  If the implementation needs to send a new flight, it transitions to the PREPARING state.  Partial reads (whether partial messages or only some of the messages in the flight) do not cause state transitions or timer resets.  <br/><br/> Because DTLS clients send the first message (ClientHello), they start in the PREPARING state.  DTLS servers start in the WAITING state, but with empty buffers and no retransmit timer.  <br/><br/> In addition, for at least twice the default Maximum Segment Lifetime (MSL) defined for <a href="#RFC0793">[RFC0793]</a>, when in the FINISHED state, the server MUST respond to retransmission of the client&#8217;s second flight with a retransmit of its ACK.  <br/><br/> Note that because of packet loss, it is possible for one side to be sending application data even though the other side has not received the first side&#8217;s Finished message.  Implementations MUST either discard or buffer all application data packets for the new epoch until they have received the Finished message for that epoch.  Implementations MAY treat receipt of application data with a new epoch prior to receipt of the corresponding Finished message as evidence of reordering or packet loss and retransmit their final flight immediately, shortcutting the retransmission timer.</li>
</ol>
<h3 id="rfc.section.5.5.2"><a href="#rfc.section.5.5.2">5.5.2.</a> <a href="#timer-values" id="timer-values">Timer Values</a></h3>
<p id="rfc.section.5.5.2.p.1">Though timer values are the choice of the implementation, mishandling of the timer can lead to serious congestion problems; for example, if many instances of a DTLS time out early and retransmit too quickly on a congested link.  Implementations SHOULD use an initial timer value of 100 msec (the minimum defined in RFC 6298 <a href="#RFC6298">[RFC6298]</a>) and double the value at each retransmission, up to no less than the RFC 6298 maximum of 60 seconds. Application specific profiles, such as those used for the Internet of Things environment, may recommend longer timer values. Note that we recommend a 100 msec timer rather than the 3-second RFC 6298 default in order to improve latency for time-sensitive applications.  Because DTLS only uses retransmission for handshake and not dataflow, the effect on congestion should be minimal.</p>
<p id="rfc.section.5.5.2.p.2">Implementations SHOULD retain the current timer value until a transmission without loss occurs, at which time the value may be reset to the initial value.  After a long period of idleness, no less than 10 times the current timer value, implementations may reset the timer to the initial value.  One situation where this might occur is when a rehandshake is used after substantial data transfer.</p>
<h2 id="rfc.section.5.6"><a href="#rfc.section.5.6">5.6.</a> <a href="#certificateverify-and-finished-messages" id="certificateverify-and-finished-messages">CertificateVerify and Finished Messages</a></h2>
<p id="rfc.section.5.6.p.1">CertificateVerify and Finished messages have the same format as in TLS 1.3.  Hash calculations include entire handshake messages, including DTLS-specific fields: message_seq, fragment_offset, and fragment_length.  However, in order to remove sensitivity to handshake message fragmentation, the CertificateVerify and the Finished messages MUST be computed as if each handshake message had been sent as a single fragment following the algorithm described in Section 4.4.3 and Section 4.4.4 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>, respectively.</p>
<h2 id="rfc.section.5.7"><a href="#rfc.section.5.7">5.7.</a> <a href="#alert-messages" id="alert-messages">Alert Messages</a></h2>
<p id="rfc.section.5.7.p.1">Note that Alert messages are not retransmitted at all, even when they occur in the context of a handshake.  However, a DTLS implementation which would ordinarily issue an alert SHOULD generate a new alert message if the offending record is received again (e.g., as a retransmitted handshake message).  Implementations SHOULD detect when a peer is persistently sending bad messages and terminate the local connection state after such misbehavior is detected.</p>
<h2 id="rfc.section.5.8"><a href="#rfc.section.5.8">5.8.</a> <a href="#establishing-new-associations-with-existing-parameters" id="establishing-new-associations-with-existing-parameters">Establishing New Associations with Existing Parameters</a></h2>
<p id="rfc.section.5.8.p.1">If a DTLS client-server pair is configured in such a way that repeated connections happen on the same host/port quartet, then it is possible that a client will silently abandon one connection and then initiate another with the same parameters (e.g., after a reboot).  This will appear to the server as a new handshake with epoch=0.  In cases where a server believes it has an existing association on a given host/port quartet and it receives an epoch=0 ClientHello, it SHOULD proceed with a new handshake but MUST NOT destroy the existing association until the client has demonstrated reachability either by completing a cookie exchange or by completing a complete handshake including delivering a verifiable Finished message.  After a correct Finished message is received, the server MUST abandon the previous association to avoid confusion between two valid associations with overlapping epochs.  The reachability requirement prevents off-path/blind attackers from destroying associations merely by sending forged ClientHellos.</p>
<h2 id="rfc.section.5.9"><a href="#rfc.section.5.9">5.9.</a> <a href="#dtls-epoch" id="dtls-epoch">Epoch Values and Rekeying</a></h2>
<p id="rfc.section.5.9.p.1">A recipient of a DTLS message needs to select the correct keying material in order to process an incoming message. With the possibility of message loss and re-order an identifier is needed to determine which cipher state has been used to protect the record payload. The epoch value fulfills this role in DTLS. In addition to the key derivation steps described in Section 7 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> triggered by the states during the handshake a sender may want to rekey at any time during the lifetime of the connection and has to have a way to indicate that it is updating its sending cryptographic keys.</p>
<p id="rfc.section.5.9.p.2">This version of DTLS assigns dedicated epoch values to messages in the protocol exchange to allow identification of the correct cipher state:</p>
<p/>

<ul>
  <li>epoch value (0) is used with unencrypted messages. There are three unencrypted messages in DTLS, namely ClientHello, ServerHello, and HelloRetryRequest.</li>
  <li>epoch value (1) is used for messages protected using keys derived from early_traffic_secret. This includes early data sent by the client and the EndOfEarlyData message.</li>
  <li>epoch value (2) is used for messages protected using keys derived from the handshake_traffic_secret. Messages transmitted during the initial handshake, such as EncryptedExtensions, CertificateRequest, Certificate, CertificateVerify, and Finished belong to this category. Note, however, post-handshake are protected under the appropriate application traffic key and are not included in this category.</li>
  <li>epoch value (3) is used for payloads protected using keys derived from the initial traffic_secret_0. This may include handshake messages, such as post-handshake messages (e.g., a NewSessionTicket message).</li>
  <li>epoch value (4 to 2^16-1) is used for payloads protected using keys from the traffic_secret_N (N&gt;0).</li>
</ul>
<p id="rfc.section.5.9.p.4">Using these reserved epoch values a receiver knows what cipher state has been used to encrypt and integrity protect a message. Implementations that receive a payload with an epoch value for which no corresponding cipher state can be determined MUST generate a &#8220;unexpected_message&#8221; alert. For example, client incorrectly uses epoch value 5 when sending early application data in a 0-RTT exchange. A server will not be able to compute the appropriate keys and will therefore have to respond with an alert.</p>
<p id="rfc.section.5.9.p.5">Increasing the epoch value by a sender (starting with value 4 upwards) corresponds semantically to rekeying using the KeyUpdate message in TLS 1.3. Instead of utilizing an dedicated message in DTLS 1.3 the sender uses an increase in the epoch value to signal rekeying. Hence, a sender that decides to increment the epoch value MUST send all its traffic using the next generation of keys, computed as described in Section 7.2 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>. Upon receiving a payload with such a new epoch value, the receiver MUST update their receiving keys and if they have not already updated their sending state up to or past the then current receiving generation MUST send messages with the new epoch value prior to sending any other messages. For epoch values lower than 4 the key schedule described in Section 7.1 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> is applicable. As a difference to the functionality of the KeyUpdate in TLS 1.3 the sender forces the receiver to increase the epoch value for outgoing data as well.</p>
<p id="rfc.section.5.9.p.6">Note that epoch values do not wrap. If a DTLS implementation would need to wrap the epoch value, it MUST terminate the connection.</p>
<p id="rfc.section.5.9.p.7">The traffic key calculation is described in Section 7.3 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>.</p>
<p><a href="#dtls-msg-epoch">Figure 11</a> illustrates the epoch values in an example DTLS handshake.</p>
<div id="rfc.figure.11"/>
<div id="dtls-msg-epoch"/>
<pre>
Client                                             Server
------                                             ------

ClientHello 
(epoch=0)
                            --------&gt;

                            &lt;--------       HelloRetryRequest
                                                    (epoch=0)

ClientHello                 --------&gt;
(epoch=0)

                            &lt;--------             ServerHello
                                                    (epoch=0)
                                        {EncryptedExtensions}
                                                    (epoch=2)
                                                {Certificate}
                                                    (epoch=2)
                                          {CertificateVerify} 
                                                    (epoch=2)
                                                   {Finished}
                                                    (epoch=2)

{Certificate}               --------&gt;
(epoch=2)
{CertificateVerify}
(epoch=2)
{Finished}
(epoch=2)

                            &lt;--------                   [Ack] 
                                                    (epoch=3)

[Application Data]         --------&gt;
(epoch=3)

                           &lt;--------       [Application Data]
                                                    (epoch=3)

                         Some time later ...
                 (Post-Handshake Message Exchange)

                           &lt;--------       [NewSessionTicket]
                                                    (epoch=3)

[Ack]                      --------&gt;
(epoch=3)
         
                         Some time later ...
                           (Rekeying)

                           &lt;--------       [Application Data]
                                                    (epoch=4)
[Application Data]         --------&gt;
(epoch=4)
</pre>
<p class="figure">Figure 11: Example DTLS Exchange with Epoch Information</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#application-data-protocol" id="application-data-protocol">Application Data Protocol</a></h1>
<p id="rfc.section.6.p.1">Application data messages are carried by the record layer and are fragmented and encrypted based on the current connection state. The messages are treated as transparent data to the record layer.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.7.p.1">Security issues are discussed primarily in <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>.</p>
<p id="rfc.section.7.p.2">The primary additional security consideration raised by DTLS is that of denial of service.  DTLS includes a cookie exchange designed to protect against denial of service.  However, implementations that do not use this cookie exchange are still vulnerable to DoS.  In particular, DTLS servers that do not use the cookie exchange may be used as attack amplifiers even if they themselves are not experiencing DoS.  Therefore, DTLS servers SHOULD use the cookie exchange unless there is good reason to believe that amplification is not a threat in their environment.  Clients MUST be prepared to do a cookie exchange with every handshake.</p>
<p id="rfc.section.7.p.3">Unlike TLS implementations, DTLS implementations SHOULD NOT respond to invalid records by terminating the connection.</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#changes-to-dtls-12" id="changes-to-dtls-12">Changes to DTLS 1.2</a></h1>
<p id="rfc.section.8.p.1">Since TLS 1.3 introduce a large number of changes to TLS 1.2, the list of changes from DTLS 1.2 to DTLS 1.3 is equally large. For this reason this section focuses on the most important changes only.</p>
<p/>

<ul>
  <li>New handshake pattern, which leads to a shorter message exchange</li>
  <li>Support for AEAD-only ciphers</li>
  <li>HelloRetryRequest of TLS 1.3 used instead of HelloVerifyRequest</li>
  <li>More flexible ciphersuite negotiation</li>
  <li>New session resumption mechanism</li>
  <li>PSK authentication redefined</li>
  <li>New key derivation hierarchy utilizing a new key derivation construct</li>
  <li>Removed support for weaker and older cryptographic algorithms</li>
  <li>Improved version negotation</li>
</ul>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.9.p.1">IANA is requested to allocate a new value in the TLS HandshakeType Registry for the ACK message defined in <a href="#ack-msg">Section 5.3</a>.</p>
<h1 id="rfc.references"><a href="#rfc.references">10.</a> References</h1>
<h2 id="rfc.references.1"><a href="#rfc.references.1">10.1.</a> Normative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-tls13-19">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-19, March 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC0793">[RFC0793]</b>
      </td>
      <td class="top"><a>Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC1191">[RFC1191]</b>
      </td>
      <td class="top"><a>Mogul, J.</a> and <a>S. Deering</a>, "<a href="http://tools.ietf.org/html/rfc1191">Path MTU discovery</a>", RFC 1191, DOI 10.17487/RFC1191, November 1990.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4443">[RFC4443]</b>
      </td>
      <td class="top"><a>Conta, A.</a>, <a>Deering, S.</a> and <a>M. Gupta</a>, "<a href="http://tools.ietf.org/html/rfc4443">Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification</a>", RFC 4443, DOI 10.17487/RFC4443, March 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4821">[RFC4821]</b>
      </td>
      <td class="top"><a>Mathis, M.</a> and <a>J. Heffner</a>, "<a href="http://tools.ietf.org/html/rfc4821">Packetization Layer Path MTU Discovery</a>", RFC 4821, DOI 10.17487/RFC4821, March 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6298">[RFC6298]</b>
      </td>
      <td class="top"><a>Paxson, V.</a>, <a>Allman, M.</a>, <a>Chu, J.</a> and <a>M. Sargent</a>, "<a href="http://tools.ietf.org/html/rfc6298">Computing TCP's Retransmission Timer</a>", RFC 6298, DOI 10.17487/RFC6298, June 2011.</td>
    </tr>
  </tbody>
</table>
<h2 id="rfc.references.2"><a href="#rfc.references.2">10.2.</a> Informative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2522">[RFC2522]</b>
      </td>
      <td class="top"><a>Karn, P.</a> and <a>W. Simpson</a>, "<a href="http://tools.ietf.org/html/rfc2522">Photuris: Session-Key Management Protocol</a>", RFC 2522, DOI 10.17487/RFC2522, March 1999.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4303">[RFC4303]</b>
      </td>
      <td class="top"><a>Kent, S.</a>, "<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>", RFC 4303, DOI 10.17487/RFC4303, December 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4340">[RFC4340]</b>
      </td>
      <td class="top"><a>Kohler, E.</a>, <a>Handley, M.</a> and <a>S. Floyd</a>, "<a href="http://tools.ietf.org/html/rfc4340">Datagram Congestion Control Protocol (DCCP)</a>", RFC 4340, DOI 10.17487/RFC4340, March 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5238">[RFC5238]</b>
      </td>
      <td class="top"><a>Phelan, T.</a>, "<a href="http://tools.ietf.org/html/rfc5238">Datagram Transport Layer Security (DTLS) over the Datagram Congestion Control Protocol (DCCP)</a>", RFC 5238, DOI 10.17487/RFC5238, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5996">[RFC5996]</b>
      </td>
      <td class="top"><a>Kaufman, C.</a>, <a>Hoffman, P.</a>, <a>Nir, Y.</a> and <a>P. Eronen</a>, "<a href="http://tools.ietf.org/html/rfc5996">Internet Key Exchange Protocol Version 2 (IKEv2)</a>", RFC 5996, DOI 10.17487/RFC5996, September 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7525">[RFC7525]</b>
      </td>
      <td class="top"><a>Sheffer, Y.</a>, <a>Holz, R.</a> and <a>P. Saint-Andre</a>, "<a href="http://tools.ietf.org/html/rfc7525">Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</a>", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#history" id="history">History</a></h1>
<p id="rfc.section.A.p.1">RFC EDITOR: PLEASE REMOVE THE THIS SECTION</p>
<p id="rfc.section.A.p.2">draft-01 - Alignment with version -19 of the TLS 1.3 specification</p>
<p id="rfc.section.A.p.3">draft-00</p>
<p/>

<ul>
  <li>Initial version using TLS 1.3 as a baseline.</li>
  <li>Use of epoch values instead of KeyUpdate message</li>
  <li>Use of cookie extension instead of cookie field in ClientHello and HelloVerifyRequest messages</li>
  <li>Added ACK message</li>
  <li>Text about sequence number handling</li>
</ul>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> <a href="#working-group-information" id="working-group-information">Working Group Information</a></h1>
<p id="rfc.section.B.p.1">The discussion list for the IETF TLS working group is located at the e-mail address <a href="mailto:tls@ietf.org">tls@ietf.org</a>. Information on the group and information on how to subscribe to the list is at <a href="https://www1.ietf.org/mailman/listinfo/tls">https://www1.ietf.org/mailman/listinfo/tls</a></p>
<p id="rfc.section.B.p.2">Archives of the list can be found at: <a href="https://www.ietf.org/mail-archive/web/tls/current/index.html">https://www.ietf.org/mail-archive/web/tls/current/index.html</a></p>
<h1 id="rfc.appendix.C"><a href="#rfc.appendix.C">Appendix C.</a> <a href="#contributors" id="contributors">Contributors</a></h1>
<p id="rfc.section.C.p.1">Many people have contributed to previous DTLS versions and they are acknowledged in prior versions of DTLS specifications.</p>
<p id="rfc.section.C.p.2">For this version of the document we would like to thank:</p>
<pre>
* Ilari Liusvaara 
  Independent
  ilariliusvaara@welho.com
</pre>
<pre>
* Martin Thomson
  Mozilla
  martin.thomson@gmail.com
</pre>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Eric Rescorla</span> 
	  <span class="n hidden">
		<span class="family-name">Rescorla</span>
	  </span>
	</span>
	<span class="org vcardline">RTFM, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ekr@rtfm.com">ekr@rtfm.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Hannes Tschofenig</span> 
	  <span class="n hidden">
		<span class="family-name">Tschofenig</span>
	  </span>
	</span>
	<span class="org vcardline">ARM Limited</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:hannes.tschofenig@arm.com">hannes.tschofenig@arm.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nagendra Modadugu</span> 
	  <span class="n hidden">
		<span class="family-name">Modadugu</span>
	  </span>
	</span>
	<span class="org vcardline">Google, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nagendra@cs.stanford.edu">nagendra@cs.stanford.edu</a></span>

  </address>
</div>

</body>
</html>
